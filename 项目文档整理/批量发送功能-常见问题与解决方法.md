# æ‰¹é‡å‘é€åŠŸèƒ½ - å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ³•

## ğŸ“‹ ç›®å½•

1. [å‘é€æŒ‰é’®ç‚¹å‡»é—®é¢˜](#å‘é€æŒ‰é’®ç‚¹å‡»é—®é¢˜)
2. [è”ç³»äººæŸ¥æ‰¾é—®é¢˜](#è”ç³»äººæŸ¥æ‰¾é—®é¢˜)
3. [å¤šé€‰æ¨¡å¼æ»šåŠ¨é—®é¢˜](#å¤šé€‰æ¨¡å¼æ»šåŠ¨é—®é¢˜)
4. [é€æ¡è½¬å‘æŒ‰é’®ç‚¹å‡»é—®é¢˜](#é€æ¡è½¬å‘æŒ‰é’®ç‚¹å‡»é—®é¢˜)

---

## ğŸ”§ å‘é€æŒ‰é’®ç‚¹å‡»é—®é¢˜

### é—®é¢˜æè¿°

åœ¨å‘é€ç¡®è®¤å¼¹çª—ä¸­,ç‚¹å‡»"å‘é€"æŒ‰é’®æ—¶,`clickNode()`è¿”å›`true`ä½†å®é™…æ²¡æœ‰ç‚¹å‡»æˆåŠŸã€‚

### é—®é¢˜åŸå› 

1. **é”™è¯¯çš„èŠ‚ç‚¹æŸ¥æ‰¾**: ä½¿ç”¨`findNodeContainingText(rootNode, "å‘é€")`ä¼šæ‰¾åˆ°é”™è¯¯çš„èŠ‚ç‚¹
   - æ‰¾åˆ°çš„æ˜¯"å‘é€ç»™ï¼š"æ ‡é¢˜æ–‡æœ¬,è€Œä¸æ˜¯"å‘é€"æŒ‰é’®
   - æ ‡é¢˜æ–‡æœ¬èŠ‚ç‚¹ä¸å¯ç‚¹å‡»

2. **ç‚¹å‡»æ–¹æ³•ä¸å¯é **: `clickNode()`åœ¨æŸäº›æƒ…å†µä¸‹è¿”å›`true`ä½†å®é™…æ²¡æœ‰è§¦å‘ç‚¹å‡»

### è§£å†³æ–¹æ¡ˆ

#### æ–¹æ¡ˆ1: ç²¾ç¡®æŸ¥æ‰¾æŒ‰é’®èŠ‚ç‚¹ âœ…

ä½¿ç”¨`resource-id`ç²¾ç¡®æŸ¥æ‰¾"å‘é€"æŒ‰é’®:

```kotlin
// âŒ é”™è¯¯æ–¹æ³•
val sendButton = findNodeContainingText(rootNode, "å‘é€")

// âœ… æ­£ç¡®æ–¹æ³•
val sendButton = findNodeByResourceId(rootNode, "com.tencent.wework:id/dbo")
```

#### æ–¹æ¡ˆ2: åŒé‡ç‚¹å‡»ç­–ç•¥ âœ…

å®ç°ä¸»æ–¹æ³•+å¤‡ç”¨æ–¹æ¡ˆçš„åŒé‡ä¿é™©:

```kotlin
// æ–¹æ³•1: performAction(ACTION_CLICK) - ä¼˜å…ˆå°è¯•
val actionClicked = confirmButton.performAction(AccessibilityNodeInfo.ACTION_CLICK)

if (actionClicked) {
    // ç­‰å¾…500msæ£€æŸ¥å¼¹çª—æ˜¯å¦å…³é—­
    handler.postDelayed({
        val stillHasDialog = rootNode?.let { 
            findNodeByResourceId(it, "com.tencent.wework:id/dbo") != null 
        } ?: false
        
        if (stillHasDialog) {
            // æ–¹æ³•1å¤±è´¥,ä½¿ç”¨æ–¹æ³•2: åæ ‡ç‚¹å‡»
            clickSendButtonByCoordinate(confirmButton, targetChat)
        } else {
            // æ–¹æ³•1æˆåŠŸ
            onSendSuccess(targetChat)
        }
    }, 500)
} else {
    // æ–¹æ³•1å¤±è´¥,ç›´æ¥ä½¿ç”¨æ–¹æ³•2
    clickSendButtonByCoordinate(confirmButton, targetChat)
}
```

#### æ–¹æ³•2: åæ ‡ç‚¹å‡»å®ç°

```kotlin
private fun clickSendButtonByCoordinate(confirmButton: AccessibilityNodeInfo, targetChat: String) {
    val rect = android.graphics.Rect()
    confirmButton.getBoundsInScreen(rect)
    
    val centerX = (rect.left + rect.right) / 2
    val centerY = (rect.top + rect.bottom) / 2
    
    val path = android.graphics.Path()
    path.moveTo(centerX.toFloat(), centerY.toFloat())
    
    val gestureBuilder = android.accessibilityservice.GestureDescription.Builder()
    val strokeDescription = android.accessibilityservice.GestureDescription.StrokeDescription(path, 0, 100)
    gestureBuilder.addStroke(strokeDescription)
    
    dispatchGesture(gestureBuilder.build(), object : GestureResultCallback() {
        override fun onCompleted(gestureDescription: GestureDescription?) {
            onSendSuccess(targetChat)
        }
        override fun onCancelled(gestureDescription: GestureDescription?) {
            onSendFailed(targetChat)
        }
    }, null)
}
```

### å…³é”®æŠ€æœ¯ç‚¹

1. **ç²¾ç¡®èŠ‚ç‚¹æŸ¥æ‰¾**: ä½¿ç”¨`resource-id`è€Œä¸æ˜¯æ–‡æœ¬æŸ¥æ‰¾
2. **åŒé‡ä¿é™©**: ä¸»æ–¹æ³•å¤±è´¥æ—¶è‡ªåŠ¨åˆ‡æ¢åˆ°å¤‡ç”¨æ–¹æ¡ˆ
3. **åŠ¨æ€åæ ‡è®¡ç®—**: ä¸ç¡¬ç¼–ç åæ ‡,è€Œæ˜¯æ ¹æ®æŒ‰é’®å®é™…ä½ç½®è®¡ç®—
4. **æ™ºèƒ½éªŒè¯**: ç‚¹å‡»åæ£€æŸ¥å¼¹çª—æ˜¯å¦å…³é—­,ç¡®è®¤ç‚¹å‡»æˆåŠŸ

---

## ğŸ” è”ç³»äººæŸ¥æ‰¾é—®é¢˜

### é—®é¢˜æè¿°

åœ¨é€‰æ‹©è”ç³»äººé¡µé¢,ç¬¬äºŒä¸ªè”ç³»äºº"å¤©å¤©ä¸€æ³‰ï½å°çŸ³æ¦´"åœ¨é¡µé¢ä¸‹æ–¹ä¸å¯è§,å¯¼è‡´`findNodeContainingText()`æ‰¾ä¸åˆ°ã€‚

### é—®é¢˜åŸå› 

1. **å¯è§æ€§é™åˆ¶**: `findNodeContainingText()`åªèƒ½æŸ¥æ‰¾å½“å‰å¯è§åŒºåŸŸçš„èŠ‚ç‚¹
2. **å­—ç¬¦ç¼–ç å·®å¼‚**: æ•°æ®åº“å­˜å‚¨çš„æ˜¯åŠè§’æ³¢æµªå·`~`,é¡µé¢æ˜¾ç¤ºçš„æ˜¯å…¨è§’æ³¢æµªå·`ï½`

### è§£å†³æ–¹æ¡ˆ

#### æ–¹æ¡ˆ1: æ»šåŠ¨æŸ¥æ‰¾æœºåˆ¶ âœ…

å®ç°æ™ºèƒ½æ»šåŠ¨,ç›´åˆ°æ‰¾åˆ°ç›®æ ‡è”ç³»äººæˆ–æ»šåŠ¨åˆ°åº•éƒ¨:

```kotlin
private fun selectTargetChat(scrollAttempts: Int = 0) {
    val targetChat = groupChats[currentChatIndex]
    val rootNode = rootInActiveWindow ?: return
    
    // æŸ¥æ‰¾ç›®æ ‡è”ç³»äºº
    val chatNode = findNodeContainingText(rootNode, targetChat)
    
    if (chatNode != null) {
        // æ‰¾åˆ°äº†,ç‚¹å‡»
        clickChatNode(chatNode, targetChat)
    } else {
        // æœªæ‰¾åˆ°,å°è¯•å‘ä¸‹æ»šåŠ¨
        val scrollableNode = findScrollableNode(rootNode)
        if (scrollableNode != null) {
            val scrolled = scrollableNode.performAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD)
            
            if (scrolled) {
                // æ»šåŠ¨æˆåŠŸ,ç­‰å¾…åç»§ç»­æŸ¥æ‰¾
                handler.postDelayed({
                    selectTargetChat(scrollAttempts + 1)
                }, 500)
            } else {
                // å·²æ»šåŠ¨åˆ°åº•éƒ¨,ä»æœªæ‰¾åˆ°
                onChatNotFound(targetChat)
            }
        } else {
            // æ‰¾ä¸åˆ°å¯æ»šåŠ¨èŠ‚ç‚¹
            onChatNotFound(targetChat)
        }
    }
}
```

#### æ–¹æ¡ˆ2: å…¨è§’/åŠè§’å­—ç¬¦æ™ºèƒ½åŒ¹é… âœ…

å®ç°æ–‡æœ¬æ ‡å‡†åŒ–,è‡ªåŠ¨å¤„ç†å…¨è§’/åŠè§’å­—ç¬¦å·®å¼‚:

```kotlin
/**
 * æ ‡å‡†åŒ–æ–‡æœ¬:å°†å…¨è§’å­—ç¬¦è½¬æ¢ä¸ºåŠè§’å­—ç¬¦,ç”¨äºæ¨¡ç³ŠåŒ¹é…
 */
private fun normalizeText(text: String): String {
    return text.map { char ->
        when (char) {
            // å…¨è§’æ³¢æµªå· â†’ åŠè§’æ³¢æµªå·
            'ï½' -> '~'
            // å…¨è§’ç©ºæ ¼ â†’ åŠè§’ç©ºæ ¼
            'ã€€' -> ' '
            // å…¨è§’æ•°å­— â†’ åŠè§’æ•°å­—
            in 'ï¼'..'ï¼™' -> (char.code - 'ï¼'.code + '0'.code).toChar()
            // å…¨è§’å­—æ¯ â†’ åŠè§’å­—æ¯
            in 'ï¼¡'..'ï¼º' -> (char.code - 'ï¼¡'.code + 'A'.code).toChar()
            in 'ï½'..'ï½š' -> (char.code - 'ï½'.code + 'a'.code).toChar()
            else -> char
        }
    }.joinToString("")
}

/**
 * æŸ¥æ‰¾åŒ…å«æŒ‡å®šæ–‡æœ¬çš„èŠ‚ç‚¹(æ”¯æŒå…¨è§’/åŠè§’æ¨¡ç³ŠåŒ¹é…)
 */
private fun findNodeContainingText(node: AccessibilityNodeInfo, text: String): AccessibilityNodeInfo? {
    val nodeText = node.text?.toString() ?: ""

    // æ ‡å‡†åŒ–åè¿›è¡Œæ¯”è¾ƒ
    val normalizedNodeText = normalizeText(nodeText)
    val normalizedSearchText = normalizeText(text)

    if (normalizedNodeText.contains(normalizedSearchText)) {
        return node
    }

    for (i in 0 until node.childCount) {
        val child = node.getChild(i) ?: continue
        val result = findNodeContainingText(child, text)
        if (result != null) return result
    }

    return null
}
```

### å…³é”®æŠ€æœ¯ç‚¹

1. **æ»šåŠ¨æŸ¥æ‰¾**: ä½¿ç”¨`ACTION_SCROLL_FORWARD`å‘ä¸‹æ»šåŠ¨,ç›´åˆ°æ‰¾åˆ°æˆ–åˆ°åº•éƒ¨
2. **æ™ºèƒ½ç­‰å¾…**: æ»šåŠ¨åç­‰å¾…500msè®©é¡µé¢åŠ è½½å®Œæˆ
3. **é€’å½’æŸ¥æ‰¾**: æ»šåŠ¨åé€’å½’è°ƒç”¨è‡ªå·±ç»§ç»­æŸ¥æ‰¾
4. **æ–‡æœ¬æ ‡å‡†åŒ–**: è‡ªåŠ¨å¤„ç†å…¨è§’/åŠè§’å­—ç¬¦å·®å¼‚,æé«˜åŒ¹é…æˆåŠŸç‡
5. **åº•éƒ¨æ£€æµ‹**: `performAction()`è¿”å›`false`è¯´æ˜å·²åˆ°åº•éƒ¨,æ— æ³•ç»§ç»­æ»šåŠ¨

### æµ‹è¯•ç»“æœ

- âœ… æˆåŠŸæ‰¾åˆ°é¡µé¢ä¸‹æ–¹çš„è”ç³»äºº
- âœ… è‡ªåŠ¨å¤„ç†å…¨è§’/åŠè§’æ³¢æµªå·å·®å¼‚
- âœ… æ»šåŠ¨åˆ°åº•éƒ¨åæ­£ç¡®æŠ¥å‘Šæœªæ‰¾åˆ°

---

## ğŸ“œ å¤šé€‰æ¨¡å¼æ»šåŠ¨é—®é¢˜

### é—®é¢˜æè¿°

åœ¨å¤šé€‰æ¨¡å¼ä¸‹,éœ€è¦å‘ä¸Šæ»šåŠ¨åŠ è½½æ›´å¤šæ¶ˆæ¯,ä½†æ‰‹åŠ¿æ»‘åŠ¨(`input swipe`)ä¸èµ·ä½œç”¨ã€‚

### é—®é¢˜åŸå› 

ä¼ä¸šå¾®ä¿¡åœ¨å¤šé€‰æ¨¡å¼ä¸‹ç¦ç”¨äº†æ‰‹åŠ¿æ»‘åŠ¨,åªèƒ½é€šè¿‡AccessibilityServiceçš„æ»šåŠ¨Actionæ¥å®ç°ã€‚

### è§£å†³æ–¹æ¡ˆ

ä½¿ç”¨`ACTION_SCROLL_BACKWARD`å‘ä¸Šæ»šåŠ¨:

```kotlin
private fun scrollToLoadMoreMessages() {
    val rootNode = rootInActiveWindow ?: return

    // æŸ¥æ‰¾å¯æ»šåŠ¨èŠ‚ç‚¹
    val scrollableNode = findScrollableNode(rootNode)

    if (scrollableNode != null) {
        Log.e(TAG, "âœ… æ‰¾åˆ°å¯æ»šåŠ¨èŠ‚ç‚¹,ä½¿ç”¨ACTION_SCROLL_BACKWARDæ»šåŠ¨")
        val scrolled = scrollableNode.performAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD)
        Log.e(TAG, "ğŸ“œ æ»šåŠ¨ç»“æœ: $scrolled")

        if (scrolled) {
            // ç­‰å¾…æ»šåŠ¨å®Œæˆåç»§ç»­å‹¾é€‰
            handler.postDelayed({
                continueSelectingMessages()
            }, 800)
        } else {
            // æ— æ³•æ»šåŠ¨,å¯èƒ½å·²ç»åˆ°é¡¶éƒ¨
            Log.e(TAG, "âš ï¸ æ— æ³•ç»§ç»­æ»šåŠ¨,å¯èƒ½å·²åˆ°é¡¶éƒ¨")
        }
    }
}

private fun findScrollableNode(node: AccessibilityNodeInfo): AccessibilityNodeInfo? {
    if (node.isScrollable) {
        return node
    }

    for (i in 0 until node.childCount) {
        val child = node.getChild(i) ?: continue
        val result = findScrollableNode(child)
        if (result != null) return result
    }

    return null
}
```

### å…³é”®æŠ€æœ¯ç‚¹

1. **ä½¿ç”¨AccessibilityAction**: `ACTION_SCROLL_BACKWARD`å‘ä¸Šæ»šåŠ¨,`ACTION_SCROLL_FORWARD`å‘ä¸‹æ»šåŠ¨
2. **æŸ¥æ‰¾å¯æ»šåŠ¨èŠ‚ç‚¹**: é€’å½’æŸ¥æ‰¾`isScrollable=true`çš„èŠ‚ç‚¹
3. **ç­‰å¾…æ»šåŠ¨å®Œæˆ**: æ»šåŠ¨åç­‰å¾…800msè®©é¡µé¢ç¨³å®š
4. **æ£€æµ‹æ»šåŠ¨ç»“æœ**: `performAction()`è¿”å›`false`è¯´æ˜æ— æ³•ç»§ç»­æ»šåŠ¨

### ä¸ºä»€ä¹ˆä¸ç”¨æ‰‹åŠ¿æ»‘åŠ¨?

```kotlin
// âŒ è¿™ç§æ–¹æ³•åœ¨å¤šé€‰æ¨¡å¼ä¸‹ä¸èµ·ä½œç”¨
adb shell input swipe 360 1200 360 400 300

// âœ… å¿…é¡»ä½¿ç”¨AccessibilityAction
scrollableNode.performAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD)
```

---

## ğŸ‘† é€æ¡è½¬å‘æŒ‰é’®ç‚¹å‡»é—®é¢˜

### é—®é¢˜æè¿°

"é€æ¡è½¬å‘"æŒ‰é’®çš„`clickable="false"`,ä½¿ç”¨`clickNode()`æ— æ³•ç‚¹å‡»ã€‚

### é—®é¢˜åŸå› 

ä¼ä¸šå¾®ä¿¡çš„"é€æ¡è½¬å‘"æŒ‰é’®è™½ç„¶å¯ä»¥ç‚¹å‡»,ä½†åœ¨UIæ ‘ä¸­æ ‡è®°ä¸º`clickable="false"`,å¯¼è‡´`performAction(ACTION_CLICK)`å¤±è´¥ã€‚

### è§£å†³æ–¹æ¡ˆ

ä½¿ç”¨åæ ‡ç‚¹å‡»:

```kotlin
private fun clickOneByOneForward() {
    val rootNode = rootInActiveWindow ?: return
    val forwardButton = findNodeContainingText(rootNode, "é€æ¡è½¬å‘") ?: return

    // è·å–æŒ‰é’®åæ ‡
    val rect = android.graphics.Rect()
    forwardButton.getBoundsInScreen(rect)

    val centerX = (rect.left + rect.right) / 2
    val centerY = (rect.top + rect.bottom) / 2

    // ä½¿ç”¨æ‰‹åŠ¿ç‚¹å‡»
    val path = android.graphics.Path()
    path.moveTo(centerX.toFloat(), centerY.toFloat())

    val gestureBuilder = android.accessibilityservice.GestureDescription.Builder()
    val strokeDescription = android.accessibilityservice.GestureDescription.StrokeDescription(path, 0, 100)
    gestureBuilder.addStroke(strokeDescription)

    dispatchGesture(gestureBuilder.build(), object : GestureResultCallback() {
        override fun onCompleted(gestureDescription: GestureDescription?) {
            Log.e(TAG, "âœ… ç‚¹å‡»'é€æ¡è½¬å‘'æˆåŠŸ")
            // ç»§ç»­ä¸‹ä¸€æ­¥
        }
    }, null)
}
```

### å…³é”®æŠ€æœ¯ç‚¹

1. **åŠ¨æ€åæ ‡è®¡ç®—**: æ ¹æ®æŒ‰é’®å®é™…ä½ç½®è®¡ç®—ä¸­å¿ƒç‚¹
2. **GestureDescription**: ä½¿ç”¨æ‰‹åŠ¿æ¨¡æ‹Ÿç‚¹å‡»
3. **å›è°ƒå¤„ç†**: åœ¨`onCompleted`ä¸­ç»§ç»­ä¸‹ä¸€æ­¥æ“ä½œ

---

## ğŸ“Š æ€»ç»“

### æ ¸å¿ƒæŠ€æœ¯è¦ç‚¹

1. **ç²¾ç¡®èŠ‚ç‚¹æŸ¥æ‰¾**: ä¼˜å…ˆä½¿ç”¨`resource-id`,é¿å…æ–‡æœ¬æŸ¥æ‰¾çš„æ­§ä¹‰
2. **åŒé‡ä¿é™©ç­–ç•¥**: ä¸»æ–¹æ³•+å¤‡ç”¨æ–¹æ¡ˆ,æé«˜æˆåŠŸç‡
3. **æ™ºèƒ½æ»šåŠ¨æŸ¥æ‰¾**: è‡ªåŠ¨æ»šåŠ¨ç›´åˆ°æ‰¾åˆ°ç›®æ ‡æˆ–åˆ°åº•éƒ¨
4. **æ–‡æœ¬æ ‡å‡†åŒ–**: å¤„ç†å…¨è§’/åŠè§’å­—ç¬¦å·®å¼‚
5. **AccessibilityAction**: åœ¨æŸäº›åœºæ™¯ä¸‹æ¯”æ‰‹åŠ¿æ»‘åŠ¨æ›´å¯é 
6. **åŠ¨æ€åæ ‡ç‚¹å‡»**: å½“èŠ‚ç‚¹ä¸å¯ç‚¹å‡»æ—¶çš„æœ‰æ•ˆæ›¿ä»£æ–¹æ¡ˆ

### è°ƒè¯•æŠ€å·§

1. **æŸ¥çœ‹UIç»“æ„**: `adb shell uiautomator dump && adb pull /sdcard/window_dump.xml`
2. **æŸ¥çœ‹æ—¥å¿—**: `adb logcat -d | grep "BatchSendService"`
3. **æµ‹è¯•æ»šåŠ¨**: `adb shell input swipe x1 y1 x2 y2 duration`
4. **æµ‹è¯•ç‚¹å‡»**: `adb shell input tap x y`

### æœ€ä½³å®è·µ

1. **ä¼˜å…ˆä½¿ç”¨resource-idæŸ¥æ‰¾èŠ‚ç‚¹**
2. **å®ç°å¤šå±‚fallbackæœºåˆ¶**
3. **æ·»åŠ è¯¦ç»†çš„æ—¥å¿—è¾“å‡º**
4. **æ™ºèƒ½ç­‰å¾…è€Œéç¡¬ç¼–ç å»¶è¿Ÿ**
5. **å¤„ç†è¾¹ç•Œæƒ…å†µ(å¦‚æ»šåŠ¨åˆ°åº•éƒ¨)**

